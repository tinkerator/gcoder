package gcoder

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"io"
	"math"
	"strings"
	"time"
)

type headType int
type HeadType headType

const (
	Laser1pt6W HeadType = iota
	Laser10W
	Laser2W
)

var LaserWattage = map[string]HeadType{
	"1.6": Laser1pt6W,
	"2":   Laser2W,
	"10":  Laser10W,
}

// LaserWidth is the mm width of the laser beam.
var LaserWidth = map[HeadType]float64{
	Laser1pt6W: 0.1,
	Laser2W:    0.01,
	Laser10W:   0.1,
}

var ToolType = map[HeadType]string{
	Laser1pt6W: "laser",
	Laser2W:    "laser",
	Laser10W:   "laser",
}

var ToolName = map[HeadType]string{
	Laser1pt6W: "levelOneLaserToolheadForSM2",
	Laser2W:    "2W Laser Module",
	Laser10W:   "levelTwoLaserToolheadForSM2",
}

func (ht HeadType) String() string {
	s, ok := ToolName[ht]
	if !ok {
		return "unknown"
	}
	return s
}

const headerFmt = `;Header Start
;header_type: %s
;tool_head: %v
;machine: Snapmaker 2.0 A350
;gcode_flavor: marlin
;renderMethod: line
;max_power: 255
;file_total_lines: %d
;estimated_time(s): %.3f
;is_rotate: false
;diameter: 0
;max_x(mm): %.3f
;max_y(mm): %.3f
;max_z(mm): 0
;max_b(mm): 0
;min_x(mm): %.3f
;min_y(mm): %.3f
;min_b(mm): 0
;min_z(mm): 0
;work_speed(mm/minute): %d
;jog_speed(mm/minute): %d
;power(%%): 100
;work_size_x: %.0f
;work_size_y: %.0f
;origin: center
;thumbnail: data:image/png;base64,%s
;Header End
;%s
;%s
`

const laserPrefix = `; Generated by zappem.net/pub/io/gcoder
; G-code START <<<
G90
G21
M2000 W1 P100
M2000 W2 P100
M3 S0
M9
M2000 L23 P1
`

const cncPrefix = `; Generated by zappem.net/pub/io/gcoder
; G-code START <<<
G90
G21
`

const laserSuffix = `M5 S0
; G-code END <<<
G91
G0 Z0 F150
G90
`

const cncSuffix = `M5
G0 Z80
`

// BBox holds the bounds for an image. Use the BBox() function to
// compute it.
type BBox struct {
	MinX, MaxX, MinY, MaxY     float64
	SpeedActive, SpeedInactive int
}

func (im *Image) BBox() *BBox {
	var started bool
	var minX, maxX, minY, maxY float64
	var speedActive, speedInactive int
	for _, s := range im.Steps {
		if s.Rel {
			if s.Speed != 0 {
				if s.Active {
					speedActive = s.Speed
				} else {
					speedInactive = s.Speed
				}
			}
			continue
		}
		if minX > s.X || !started {
			minX = s.X
		}
		if maxX < s.X || !started {
			maxX = s.X
		}
		if minY > s.Y || !started {
			minY = s.Y
		}
		if maxY < s.Y || !started {
			maxY = s.Y
		}
		started = true
	}
	return &BBox{
		MinX:          minX - 3,
		MaxX:          maxX + 3,
		MinY:          minY - 3,
		MaxY:          maxY + 3,
		SpeedActive:   speedActive,
		SpeedInactive: speedInactive,
	}
}

// A350Laser writes the gcode formatted for a Snapmaker 2 A350 level
// one laser tool head.
func (im *Image) A350Laser(ht HeadType, wr io.Writer, pngImage []byte) error {
	bb := im.BBox()

	code := &bytes.Buffer{}
	fmt.Fprint(code, laserPrefix)

	power := 0.0
	unimplemented := false

	var penX, penY, penZ, dX, dY, dZ float64
	var speedActive, speedInactive int

	var duration time.Duration
	for cp := 0; cp < im.Copies; cp++ {
		for i, s := range im.Steps {
			if s.Comment != "" {
				fmt.Fprintf(code, "; %q\n", s.Comment)
				continue
			}
			if s.Command != CmdInvalid {
				switch s.Command {
				case CmdSetOrigin:
					fmt.Fprint(code, "G92 X0 Y0 Z0\n")
				default:
					return fmt.Errorf("unrecognized command %d", s.Command)
				}
				continue
			}
			if s.Rel {
				penZ, dZ = penZ+s.Z, s.Z
				power = s.Power
				if dZ != 0 {
					drive := 0
					speed := speedInactive
					if power != 0 {
						speed = speedActive
						drive = 1
					}
					if speed == 0 {
						speed = 140
					}
					fmt.Fprintf(code, "M3 P%g\n; adjusting Z to %.3f (by %.3fmm)\nG91\nG%d Z%.3f F%d\nG90\n", power, penZ, dZ, drive, dZ, speed)
					duration += time.Millisecond * time.Duration(60000*math.Abs(dZ)/float64(speed))
					continue
				}
				if s.Speed != 0 {
					if s.Active {
						fmt.Fprintf(code, "G1 F%d\n", s.Speed)
						speedActive = s.Speed
						continue
					} else {
						fmt.Fprintf(code, "G0 F%d\n", s.Speed)
						speedInactive = s.Speed
						continue
					}
				}
				fmt.Fprintf(code, ";[%d] unimplemented %#v\n", i, *s)
				unimplemented = true
				continue
			}
			if s.Z != 0 {
				penZ = s.Z
			}
			dX, penX = s.X-penX, s.X
			dY, penY = s.Y-penY, s.Y

			dist := math.Sqrt(dX*dX + dY*dY)
			if s.Active {
				duration += time.Millisecond * time.Duration(60000*dist/float64(speedActive))
				if power == s.Power {
					fmt.Fprintf(code, "G1 X%.3f Y%.3f\n", s.X, s.Y)
					continue
				}
				fmt.Fprintf(code, "; power %.1f%%\nG1 X%.3f Y%.3f S%d\n", s.Power, s.X, s.Y, int(0.5+255*s.Power/100))
			} else {
				duration += time.Millisecond * time.Duration(60000*dist/float64(speedInactive))
				fmt.Fprintf(code, "G0 X%.3f Y%.3f\n", s.X, s.Y)
			}
			// Be sure to reset power. This causes the program to
			// remember to be explicit the next time a G1 command
			// is run after a G0 command.
			power = s.Power
		}
	}
	fmt.Fprint(code, laserSuffix)

	if unimplemented {
		return fmt.Errorf("failed to digest:\n%s", code.String())
	}

	b64e := base64.StdEncoding.EncodeToString(pngImage)
	lines := strings.Count(code.String(), "\n") + strings.Count(headerFmt, "\n")
	seconds := float64(duration) / float64(time.Second)
	header := fmt.Sprintf(headerFmt, "laser", ht, lines, seconds, bb.MaxX, bb.MaxY, bb.MinX, bb.MinY, bb.SpeedActive, bb.SpeedInactive, bb.MaxX-bb.MinX, bb.MaxY-bb.MinY, b64e, gCoderRevision, time.Now().Format(time.DateTime))

	fmt.Fprint(wr, header, code.String())
	return nil
}

// A350CNC writes the gcode formatted for a Snapmaker 2 A350 standard
// CNC head. The work origin is an important feature, as all X,Y moves
// are absolute.
func (im *Image) A350CNC(wr io.Writer, pngImage []byte) error {
	bb := im.BBox()

	code := &bytes.Buffer{}
	fmt.Fprint(code, cncPrefix)

	power := 0.0
	unimplemented := false

	var penX, penY, penZ, dX, dY, dZ float64
	var speedActive, speedInactive int

	var duration time.Duration
	for i, s := range im.Steps {
		if s.Comment != "" {
			fmt.Fprintf(code, "; %q\n", s.Comment)
			continue
		}
		if s.Command != CmdInvalid {
			switch s.Command {
			case CmdSetOrigin:
				fmt.Fprint(code, "G92 X0 Y0 Z0\n")
			default:
				return fmt.Errorf("unrecognized command %d", s.Command)
			}
			continue
		}
		if s.Rel {
			penZ, dZ = penZ+s.Z, s.Z
			power = s.Power
			if dZ != 0 {
				drive := 0
				speed := speedInactive
				if power != 0 {
					speed = speedActive
					drive = 1
				}
				if speed == 0 {
					speed = 140
				}
				fmt.Fprintf(code, "M3 P%g\n; adjusting Z to %.3f (by %.3fmm)\nG91\nG%d Z%.3f F%d\nG90\n", power, penZ, dZ, drive, dZ, speed)
				duration += time.Millisecond * time.Duration(60000*math.Abs(dZ)/float64(speed))
				continue
			}
			if s.Speed != 0 {
				if s.Active {
					fmt.Fprintf(code, "G1 F%d\n", s.Speed)
					speedActive = s.Speed
					continue
				} else {
					fmt.Fprintf(code, "G0 F%d\n", s.Speed)
					speedInactive = s.Speed
					continue
				}
			}
			fmt.Fprintf(code, ";[%d] unimplemented %#v\n", i, *s)
			unimplemented = true
			continue
		}
		if s.Z != 0 {
			penZ = s.Z
		}
		dX, penX = s.X-penX, s.X
		dY, penY = s.Y-penY, s.Y

		dist := math.Sqrt(dX*dX + dY*dY)
		if s.Active {
			duration += time.Millisecond * time.Duration(60000*dist/float64(speedActive))
			if power == s.Power {
				fmt.Fprintf(code, "G1 X%.3f Y%.3f\n", s.X, s.Y)
				continue
			}
			fmt.Fprintf(code, "G1 X%.3f Y%.3f P%g\n", s.X, s.Y, s.Power)
		} else {
			duration += time.Millisecond * time.Duration(60000*dist/float64(speedInactive))
			fmt.Fprintf(code, "G0 X%.3f Y%.3f\n", s.X, s.Y)
		}
		// Be sure to reset power. This causes the program to
		// remember to be explicit the next time a G1 command
		// is run after a G0 command.
		power = s.Power
	}
	fmt.Fprint(code, cncSuffix)

	if unimplemented {
		return fmt.Errorf("failed to digest:\n%s", code.String())
	}

	b64e := base64.StdEncoding.EncodeToString(pngImage)
	lines := strings.Count(code.String(), "\n") + strings.Count(headerFmt, "\n")
	seconds := float64(duration) / float64(time.Second)
	header := fmt.Sprintf(headerFmt, "cnc", "standardCNCToolheadForSM2", lines, seconds, bb.MaxX, bb.MaxY, bb.MinX, bb.MinY, bb.SpeedActive, bb.SpeedInactive, bb.MaxX-bb.MinX, bb.MaxY-bb.MinY, b64e, "G-coder unreleased", time.Now().Format(time.DateTime))

	fmt.Fprint(wr, header, code.String())
	return nil
}
